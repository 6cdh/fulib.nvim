# fulib.nvim

A Functional library in Fennel for nvim.

This doc is generated by `scripts/doc.fnl`.

## type hints

This lib uses haskell-like type annotation.
Its syntax is

```
first_argument_type [-> second_argument_type [-> ...]] -> return type
```

For example, a function with type `a -> b` means it accepts a type `a` parameter
and have return a type `b` value. The type annotation `a -> b -> c` means it accepts two
parameters: the first is type `a` and the second type `b`, and return type `c`.

- `bool`: bool
- `number`: number
- `string`: string
- `list` or `[v]`: the tables that is empty or contains not-nil value at the index 1
- `table` or `{k v}`: table
- `any`: any type
- `(a -> b)`: function type that accepts type `a` and return type `b`
- `[a|b]`: type `a` or type `b`

## number

#### inc

```fennel
(inc num)
[number|string] -> number
```

O(1). Increase `num`. `num` may be a number or string that can be converted to a number.

#### dec

```fennel
(dec num)
[number|string] -> number
```

O(1). Decrease `num`. `num` may be a number or string that can be converted to a number.

#### odd?

```fennel
(odd? num)
[number|string] -> bool
```

O(1). Return true if `num` is odd, false otherwise. If `num` is a string, it must be
convertible to a number.

#### even?

```fennel
(even? num)
[number|string] -> bool
```

O(1). Return true if `num` is even, false otherwise. If `num` is a string, it must be
convertible to a number.

## type

#### nil?

```fennel
(nil? v)
any -> bool
```

O(1). Return true if `v` is nil, false otherwise.

#### not-nil?

```fennel
(not-nil? v)
any -> bool
```

O(1). Return false if `v` is nil, true otherwise.

#### table?

```fennel
(table? v)
any -> bool
```

O(1). Return true if `v` is a table, false otherwise.

#### not-table?

```fennel
(not-table? v)
any -> bool
```

O(1). Return false if `v` is a table, true otherwise.

#### list?

```fennel
(list? v)
any -> bool
```

O(1). Return true if `v` is a list, false otherwise. A table `t` is a list if it is empty
or `t[1] != nil`.

#### not-list?

```fennel
(not-list? v)
any -> bool
```

O(1). Return false if `v` is a list, true otherwise. A table `t` is a list if it is empty
or `t[1] != nil`.

#### eq?

```fennel
(eq? v1 v2)
any -> any -> bool
```

O(1) if `v1` and `v2` are not both table, otherwise it compares `v1` and `v2`
recursively. Basically the same as `v1 == v2` in Lua except

- for table, it will perform `eq?` for each key and corresponding value.
- for number, it will perform float equality comparisons.

#### not-eq?

```fennel
(not-eq? v1 v2)
any -> any -> bool
```

O(1) if `v1` and `v2` are not both table. Basically the same as `v1 ~= v2` in Lua except

- for table, it will perform `not-eq?` for each key and corresponding value.
- for number, it will perform float equality comparisons.

## Lisp primitives

#### cons

```fennel
(cons elem lst)
any -> list -> list
```

O(n). Insert `elem` in front of `lst`. A new list would be created and returned.

#### car

```fennel
(car lst)
list -> any
```

O(1). Return the first element of `lst`.

#### cdr

```fennel
(cdr lst)
list -> list
```

O(n). Remove the first element of `lst` and return `lst`. A new table would be created
and returned.

## Table/List

#### copy

```fennel
(copy tbl)
table -> table
```

O(n). Return a copy of `tbl`.

#### empty?

```fennel
(empty? v)
[table|string] -> bool
```

O(1). Return true if `v` is an empty string or empty table, false otherwise.

#### not-empty?

```fennel
(not-empty? v)
[table|string] -> bool
```

O(1). Return false if `v` is an empty string or empty table, true otherwise.

#### member?

```fennel
(member? elem tbl)
any -> table -> bool
```

O(n). Return true if `elem` is one of the values of `tbl`, false otherwise.

#### not-member?

```fennel
(not-member? elem tbl)
any -> table -> bool
```

O(n). Return false if `elem` is one of the values of `tbl`, true otherwise.

#### table-keys

```fennel
(table-keys tbl)
table -> list
```

O(n). Return the list of keys of `tbl`.

#### table-values

```fennel
(table-values tbl)
table -> list
```

O(n). Return the list of values of `tbl`.

#### append

```fennel
(append tbl v)
list -> any -> list
```

O(1). Append `v` into `tbl`.

## Common functional utils

#### id

```fennel
(id v)
any -> any
```

O(1). Identity function.

#### all

```fennel
(all pred tbl)
[(v -> k -> bool)|(v -> bool)] -> {k v}
```

O(n \* pred). Return true if predicate `pred` return true for all elements of `tbl`,
false otherwise.

#### any

```fennel
(any pred tbl)
[(v -> k -> bool)|(v -> bool)] -> {k v}
```

O(n \* pred). Return true if predicate `pred` return true for at least elements of `tbl`,
false otherwise.

#### for_each

```fennel
(for_each f tbl)
[(v -> k -> any)|(v -> any)] -> [table|list] -> [table|list]
```

O(n \* f). Apply function `f` for all elements of `tbl` without change `tbl` or create a new
list.

#### map

```fennel
(map f tbl)
[(v -> k -> any)|(v -> any)] -> table -> table
```

O(n \* f). Like `for_each` but a new table would be created.

#### filter

```fennel
(filter pred tbl)
[(v -> k -> bool)|(v -> bool)] -> table -> table
```

O(n \* pred). Return a new list with the elements of `tbl` for which `pred` returns true.

#### foldl

```fennel
(foldl f init lst)
[(init -> v -> k -> init)|(init -> v -> init)] -> init -> table -> init
```

O(n \* f). Start with `init`, reduce `lst` with function `f`, from left to right.

#### foldr

```fennel
(foldr f init lst)
[(v -> init -> k -> init)|(v -> init -> init)] -> init -> table -> init
```

O(n \* f). Start with `init`, reduce `lst` with function `f`, from right to left.

#### reverse

```fennel
(reverse lst)
list -> list
```

O(n). Reverse `lst`.

#### intersect

```fennel
(intersect tbl1 tbl2)
table -> table -> list
```

O(n). Return the intersection of `tbl1` and `tbl2`.

#### zip_with

```fennel
(zip_with f lst1 lst2)
(v1 -> v2 -> any) -> list -> list -> list
```

O(min(m, n)). Return a list corresponding pair of `lst1` and `lst2`.

#### zip

```fennel
(zip lst1 lst2)
table -> table -> list
```

O(min(m, n)). Return a list of corresponding pair of `lst1` and `lst2`.
